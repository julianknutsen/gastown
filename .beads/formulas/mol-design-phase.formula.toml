# Design Phase Formula
#
# Deep requirements gathering and architecture design with Rule-of-5 refinement.
# Ends with a PR from polecat branch to main on fork.
#
# Usage:
#   gt sling mol-design-phase <polecat> --var issue=gt-xxxx
#
# This formula combines:
# 1. Requirements gathering from the bead
# 2. Codebase exploration for context
# 3. Convoy-style parallel design analysis (6 dimensions)
# 4. Synthesis into unified design doc
# 5. Rule-of-5 iterative refinement (opus tier)
# 6. Branch push + PR creation (no refinery)

description = """
Deep design phase for a task or bug, producing a reviewed architecture document.

## Workflow

1. **Gather Requirements**: Extract full context from the assigned bead
2. **Explore Codebase**: Find relevant code, patterns, and constraints
3. **Parallel Design Analysis** (convoy-style):
   - API & Interface design
   - Data Model design
   - User Experience analysis
   - Scalability analysis
   - Security analysis
   - Integration analysis
4. **Synthesize**: Combine all dimensions into unified design doc
5. **Rule-of-5 Refinement**: 4 iterative passes (correctness → clarity → edge cases → excellence)
6. **Create PR**: Push branch and create PR to main on fork

## Output

- `.designs/{{issue}}/` directory with:
  - Individual dimension analyses (api.md, data.md, etc.)
  - Unified design-doc.md
- PR from `design/{{issue}}` branch to `main`

## Variables

| Variable | Required | Description |
|----------|----------|-------------|
| issue | yes | Bead ID to design for (e.g., gt-xxxx) |
"""
formula = "mol-design-phase"
type = "workflow"
version = 1

# =============================================================================
# PHASE 1: REQUIREMENTS GATHERING
# =============================================================================

[[steps]]
id = "gather-requirements"
title = "Gather requirements from bead"
tier = "opus"
description = """
Extract comprehensive requirements from the assigned issue bead.

**1. Load the issue:**
```bash
bd show {{issue}}
```

**2. Capture key information:**
- Title and description
- Type (bug, feature, task, epic)
- Labels and priority
- Any linked issues or dependencies
- Comments or discussion history

**3. Create requirements summary:**
```bash
mkdir -p .designs/{{issue}}
```

Write to `.designs/{{issue}}/requirements.md`:
```markdown
# Requirements: {{issue}}

## Original Issue
(Full issue content)

## Problem Statement
(1-2 paragraph clear statement of what needs to be solved)

## Success Criteria
(Bulleted list: how do we know this is done?)

## Constraints
(Known constraints: backwards compatibility, performance, etc.)

## Open Questions
(Questions needing clarification before design)
```

**4. If critical questions exist:**
Mail the human for clarification before proceeding:
```bash
gt mail send --human -s "Design clarification needed: {{issue}}" -m "..."
```

**Exit criteria:** requirements.md written with clear problem statement and success criteria.
"""

# =============================================================================
# PHASE 2: CODEBASE EXPLORATION
# =============================================================================

[[steps]]
id = "explore-codebase"
title = "Explore codebase for context"
needs = ["gather-requirements"]
tier = "opus"
description = """
Find relevant code, patterns, and constraints in the codebase.

**1. Identify relevant areas:**
Based on the requirements, determine which parts of the codebase are relevant:
- Which packages/modules?
- Which commands or APIs?
- Which data structures?

**2. Explore the code:**
```bash
# Find relevant files
glob "**/*relevant*"
grep "pattern" --type go

# Read key files
# Understand existing patterns
```

**3. Document findings:**
Write to `.designs/{{issue}}/codebase-context.md`:
```markdown
# Codebase Context: {{issue}}

## Relevant Files
| File | Purpose | Relevance |
|------|---------|-----------|
| path/to/file.go | Description | How it relates |

## Existing Patterns
(How similar things are done in this codebase)

## Key Data Structures
(Relevant types, schemas, models)

## Integration Points
(Where new code would connect to existing code)

## Constraints from Code
(Technical constraints discovered: dependencies, APIs, etc.)
```

**Exit criteria:** codebase-context.md written with relevant files and patterns identified.
"""

# =============================================================================
# PHASE 3: PARALLEL DESIGN ANALYSIS (CONVOY-STYLE)
# =============================================================================
# These 6 steps all depend only on explore-codebase, so they can run in parallel.

[[steps]]
id = "analyze-api"
title = "API & Interface Design"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze interface design for this feature.

**Read context:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Command-line interface: flags, subcommands, ergonomics
- Programmatic API: function signatures, return types
- Configuration interface: files, environment variables
- Error messages and help text
- Naming conventions and discoverability
- Consistency with existing interfaces

**Questions to answer:**
- How will users discover and learn this feature?
- What's the happy path vs edge cases?
- Does it follow existing CLI/API patterns?
- What would make this a joy to use?

**Write to:** `.designs/{{issue}}/api.md`

Use the standard dimension analysis format:
```markdown
# API & Interface Design

## Summary
(1-2 paragraph overview)

## Key Considerations
(Bulleted list)

## Options Explored
### Option 1: ...
- Description, Pros, Cons, Effort

## Recommendation
(Your recommended approach)

## Open Questions
(Questions needing human input)
```

**Exit criteria:** api.md written with interface proposals.
"""

[[steps]]
id = "analyze-data"
title = "Data Model Design"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze data model requirements for this feature.

**Read context:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Data structures: types, relationships, constraints
- Storage format: JSON, TOML, SQLite, in-memory
- Schema design: fields, indices, normalization
- Migration strategy: versioning, backwards compatibility
- Data lifecycle: creation, updates, deletion
- Persistence vs ephemeral considerations

**Questions to answer:**
- What data needs to persist vs be computed?
- How will the data grow over time?
- What queries/access patterns are needed?
- How do we handle schema evolution?

**Write to:** `.designs/{{issue}}/data.md`

**Exit criteria:** data.md written with data model proposals.
"""

[[steps]]
id = "analyze-ux"
title = "User Experience Analysis"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze user experience implications of this feature.

**Read context:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Mental model: how users think about this
- Workflow integration: where does this fit in daily use?
- Learning curve: progressive disclosure
- Error experience: what happens when things go wrong?
- Feedback: how does the user know it's working?
- Discoverability: --help, docs, examples

**Questions to answer:**
- What's the user's goal when using this?
- What's the minimum viable interaction?
- How do we handle power users vs beginners?
- What would surprise or confuse users?

**Write to:** `.designs/{{issue}}/ux.md`

**Exit criteria:** ux.md written with UX recommendations.
"""

[[steps]]
id = "analyze-scale"
title = "Scalability Analysis"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze scalability implications of this feature.

**Read context:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Scale dimensions: data size, request rate, user count
- Resource usage: memory, CPU, disk, network
- Bottlenecks: what limits growth?
- Complexity: algorithmic, space, time
- Caching opportunities
- Degradation modes: what happens at limits?

**Questions to answer:**
- What happens at 10x, 100x, 1000x current scale?
- What are the hard limits?
- Where should we optimize vs keep simple?
- What needs to be lazy vs eager?

**Write to:** `.designs/{{issue}}/scale.md`

**Exit criteria:** scale.md written with scalability analysis.
"""

[[steps]]
id = "analyze-security"
title = "Security Analysis"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze security implications of this feature.

**Read context:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Trust boundaries: what trusts what?
- Attack surface: new inputs, outputs, permissions
- Threat model: who might attack this and how?
- Sensitive data: what's exposed or stored?
- Authentication/authorization implications
- Failure modes: what if security fails?

**Questions to answer:**
- What's the worst case if this is exploited?
- What new permissions or access does this need?
- How do we validate/sanitize inputs?
- Are there defense-in-depth opportunities?

**Write to:** `.designs/{{issue}}/security.md`

**Exit criteria:** security.md written with security analysis.
"""

[[steps]]
id = "analyze-integration"
title = "Integration Analysis"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze how this feature integrates with the existing system.

**Read context:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Existing components: what does this touch?
- Dependencies: what does this need from others?
- Dependents: what will depend on this?
- Migration path: how do we get from here to there?
- Backwards compatibility: what might break?
- Testing strategy: how do we verify integration?

**Questions to answer:**
- Where does this code live?
- How does it affect existing workflows?
- What needs to change in dependent code?
- Can we feature-flag or gradually roll out?

**Write to:** `.designs/{{issue}}/integration.md`

**Exit criteria:** integration.md written with integration plan.
"""

# =============================================================================
# PHASE 4: SYNTHESIS
# =============================================================================

[[steps]]
id = "synthesize"
title = "Synthesize design document"
needs = ["analyze-api", "analyze-data", "analyze-ux", "analyze-scale", "analyze-security", "analyze-integration"]
tier = "opus"
description = """
Combine all dimension analyses into a unified design document.

**Read all dimension analyses:**
- `.designs/{{issue}}/api.md`
- `.designs/{{issue}}/data.md`
- `.designs/{{issue}}/ux.md`
- `.designs/{{issue}}/scale.md`
- `.designs/{{issue}}/security.md`
- `.designs/{{issue}}/integration.md`

**Write unified design to:** `.designs/{{issue}}/design-doc.md`

```markdown
# Design: {{issue}}

## Executive Summary
(2-3 paragraph overview of proposed design)

## Problem Statement
(Clear statement of what we're solving, from requirements.md)

## Proposed Design

### Overview
(High-level approach)

### Key Components
(Main pieces and how they fit together)

### Interface
(CLI/API summary from api dimension)

### Data Model
(Schema summary from data dimension)

## Trade-offs and Decisions

### Decisions Made
(Key choices and rationale)

### Open Questions
(Decisions needing human input - HIGHLIGHT THESE)

### Trade-offs
(What we're trading off and why)

## Risks and Mitigations
(From security and scale dimensions)

## Implementation Plan
(From integration dimension)

### Phase 1: MVP
### Phase 2: Polish
### Phase 3: Future

## Appendix: Dimension Analyses
- [API Design](api.md)
- [Data Model](data.md)
- [User Experience](ux.md)
- [Scalability](scale.md)
- [Security](security.md)
- [Integration](integration.md)
```

**Identify conflicts** between dimensions and flag them clearly.
**Highlight open questions** that need human decision.

**Exit criteria:** design-doc.md synthesized from all dimensions.
"""

# =============================================================================
# PHASE 5: RULE-OF-5 REFINEMENT
# =============================================================================

[[steps]]
id = "refine-correctness"
title = "Refine 1: Correctness"
needs = ["synthesize"]
tier = "opus"
description = """
First refinement pass on the design document.

**Focus: CORRECTNESS**

Read `.designs/{{issue}}/design-doc.md` and check:
- Is the logic sound?
- Are there errors, bugs, or mistakes in the design?
- Do the proposed interfaces actually work?
- Are the data model relationships correct?
- Do the security assumptions hold?
- Are there contradictions between sections?

**Fix all issues found.** Don't just note them - update design-doc.md directly.

Also review and update dimension analyses if needed.

**Exit criteria:** Design is logically sound and internally consistent.
"""

[[steps]]
id = "refine-clarity"
title = "Refine 2: Clarity"
needs = ["refine-correctness"]
tier = "opus"
description = """
Second refinement pass on the design document.

**Focus: CLARITY**

Read `.designs/{{issue}}/design-doc.md` and improve:
- Can someone unfamiliar with this understand it?
- Is there jargon that needs explanation?
- Are the diagrams/examples helpful?
- Is the structure logical and easy to navigate?
- Are decisions clearly explained with rationale?
- Remove unnecessary complexity in explanations

**Simplify and clarify.** Update design-doc.md directly.

**Exit criteria:** Design is clear and understandable to newcomers.
"""

[[steps]]
id = "refine-edge-cases"
title = "Refine 3: Edge Cases"
needs = ["refine-clarity"]
tier = "opus"
description = """
Third refinement pass on the design document.

**Focus: EDGE CASES**

Read `.designs/{{issue}}/design-doc.md` and consider:
- What could go wrong?
- What's missing from the design?
- How does it handle unusual inputs?
- What about error conditions?
- Concurrency issues?
- Migration edge cases?
- What if dependencies fail?

**Add handling for edge cases.** Update design-doc.md directly.

Add a new section if needed:
```markdown
## Edge Cases and Error Handling
(Document how the design handles unusual situations)
```

**Exit criteria:** Design handles edge cases and failure modes.
"""

[[steps]]
id = "refine-excellence"
title = "Refine 4: Excellence"
needs = ["refine-edge-cases"]
tier = "opus"
description = """
Final refinement pass on the design document.

**Focus: EXCELLENCE**

This is the last pass. Read `.designs/{{issue}}/design-doc.md` and ask:
- Is this something we'd be proud to ship?
- Does it feel elegant and well-thought-out?
- Are there any rough edges to smooth?
- Is the implementation plan actionable?
- Would a developer know exactly what to build from this?

**Polish to excellence.** Update design-doc.md directly.

Ensure:
- Executive summary is compelling
- Open questions are clearly highlighted
- Implementation phases are realistic
- The document tells a coherent story

**Exit criteria:** Design document is excellent and ready for review.
"""

# =============================================================================
# PHASE 6: CREATE PR
# =============================================================================

[[steps]]
id = "create-pr"
title = "Create PR to main"
needs = ["refine-excellence"]
tier = "opus"
description = """
Push the design to a branch and create a PR to main.

**1. Create and switch to design branch:**
```bash
git checkout -b design/{{issue}}
```

**2. Stage the design files:**
```bash
git add .designs/{{issue}}/
```

**3. Commit the design:**
```bash
git commit -m "design: architecture for {{issue}}

Adds comprehensive design document with:
- Requirements analysis
- 6-dimension design exploration (API, data, UX, scale, security, integration)
- Rule-of-5 refined design document
- Implementation plan

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

**4. Push the branch:**
```bash
git push -u origin design/{{issue}}
```

**5. Create PR to main on fork:**
```bash
gh pr create \
  --base main \
  --head design/{{issue}} \
  --title "Design: $(bd show {{issue}} --json | jq -r '.title')" \
  --body "$(cat <<'EOF'
## Design Document for {{issue}}

This PR contains the architecture design for the referenced issue.

### Contents
- `requirements.md` - Problem statement and success criteria
- `codebase-context.md` - Relevant code and patterns
- Dimension analyses: api.md, data.md, ux.md, scale.md, security.md, integration.md
- `design-doc.md` - Unified design document (Rule-of-5 refined)

### Review Focus
Please review:
1. **Open Questions** section - decisions needing human input
2. **Trade-offs** - are these acceptable?
3. **Implementation Plan** - is this realistic?

---
$(cat .designs/{{issue}}/design-doc.md | head -100)
...

[See full design document in PR files]
EOF
)"
```

**6. Report completion:**
```bash
bd update {{issue}} --notes "Design PR created: $(gh pr view --json url -q '.url')"
```

**Exit criteria:** PR created, URL recorded in bead notes.
"""

# =============================================================================
# VARIABLES
# =============================================================================

[vars]
[vars.issue]
description = "Bead ID to design for (e.g., gt-xxxx)"
required = true
