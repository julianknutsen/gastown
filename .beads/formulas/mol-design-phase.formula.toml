# Design Phase Formula
#
# Workflow with requirements gathering, 6-dimension analysis, Rule-of-5, and PR creation.
#
# Usage (from bead):
#   gt sling mol-design-phase gastown --var issue=gt-xxxx
#
# Usage (from problem string):
#   gt sling mol-design-phase gastown --var problem="Add model selection for roles"
#
# Workflow:
# 1. Gather requirements from bead or problem string
# 2. Explore codebase for context
# 3. 6 dimension analysis (sequential)
# 4. Synthesis with Rule-of-5 refinement
# 5. Create PR from polecat branch

description = """
Deep design phase for a task or bug, producing a reviewed architecture document.

## Workflow

1. **Gather Requirements**: Extract full context from the assigned bead
2. **Explore Codebase**: Find relevant code, patterns, and constraints
3. **Design Analysis** (6 dimensions):
   - API & Interface design
   - Data Model design
   - User Experience analysis
   - Scalability analysis
   - Security analysis
   - Integration analysis
4. **Synthesize** â†’ Expanded with Rule-of-5:
   - Draft (initial synthesis)
   - Refine 1: Correctness
   - Refine 2: Clarity
   - Refine 3: Edge Cases
   - Refine 4: Excellence
5. **Create PR**: Push polecat branch, create PR to main

## Output

- `.designs/{{issue}}/` directory with:
  - requirements.md, codebase-context.md
  - Dimension analyses (api.md, data.md, ux.md, scale.md, security.md, integration.md)
  - design-doc.md (Rule-of-5 refined)
- PR from polecat branch to main
"""
formula = "mol-design-phase"
type = "workflow"
version = 1

# =============================================================================
# PRE-STEPS: Requirements & Context
# =============================================================================

[[steps]]
id = "gather-requirements"
title = "Gather requirements"
tier = "opus"
description = """
Extract comprehensive requirements from the bead or problem statement.

**Determine input mode:**
- If `{{issue}}` is provided: Read from bead
- If `{{problem}}` is provided: Use the problem string directly

**1. Create output directory:**
```bash
# Use issue ID if available, otherwise generate from problem
DESIGN_ID="{{issue}}"
if [ -z "$DESIGN_ID" ] || [ "$DESIGN_ID" = "{{issue}}" ]; then
  # Generate ID from problem string (first 30 chars, slugified)
  DESIGN_ID=$(echo "{{problem}}" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | cut -c1-30)
fi
mkdir -p ".designs/$DESIGN_ID"
```

**2a. If issue bead provided:**
```bash
bd show {{issue}}
# Extract full content and write to requirements.md
```

**2b. If problem string provided:**
Use the problem statement directly as the starting point.

**3. Write requirements summary to `.designs/<id>/requirements.md`:**
```markdown
# Requirements

## Original Issue/Problem
(Full issue content from bd show, OR the problem string)

## Problem Statement
(1-2 paragraph clear statement of what needs to be solved)

## Success Criteria
(Bulleted list: how do we know this is done?)

## Constraints
(Known constraints: backwards compatibility, performance, etc.)

## Open Questions
(Questions needing clarification before design)
```

**Exit criteria:** requirements.md written with clear problem statement.
"""

[[steps]]
id = "explore-codebase"
title = "Explore codebase for context"
needs = ["gather-requirements"]
tier = "opus"
description = """
Find relevant code, patterns, and constraints in the codebase.

**1. Based on requirements, identify relevant areas:**
- Which packages/modules?
- Which commands or APIs?
- Which data structures?

**2. Explore and document findings to `.designs/{{issue}}/codebase-context.md`:**
```markdown
# Codebase Context

## Relevant Files
| File | Purpose | Relevance |
|------|---------|-----------|
| path/to/file.go | Description | How it relates |

## Existing Patterns
(How similar things are done in this codebase)

## Key Data Structures
(Relevant types, schemas, models)

## Integration Points
(Where new code would connect to existing code)

## Constraints from Code
(Technical constraints discovered)
```

**Exit criteria:** codebase-context.md written with relevant files and patterns.
"""

# =============================================================================
# ANALYSIS STEPS: 6 Dimensions
# =============================================================================

[[steps]]
id = "analyze-api"
title = "API & Interface Design"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze the interface design for this feature.

**Read context first:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Command-line interface: flags, subcommands, ergonomics
- Programmatic API: function signatures, return types
- Configuration interface: files, environment variables
- Error messages and help text
- Naming conventions and discoverability
- Consistency with existing interfaces

**Questions to answer:**
- How will users discover and learn this feature?
- What's the happy path vs edge cases?
- Does it follow existing CLI/API patterns?

**Write to:** `.designs/{{issue}}/api.md`

**Exit criteria:** api.md written with interface analysis.
"""

[[steps]]
id = "analyze-data"
title = "Data Model Design"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze the data model requirements for this feature.

**Read context first:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Data structures: types, relationships, constraints
- Storage format: JSON, TOML, SQLite, in-memory
- Schema design: fields, indices, normalization
- Migration strategy: versioning, backwards compatibility
- Data lifecycle: creation, updates, deletion

**Questions to answer:**
- What data needs to persist vs be computed?
- How will the data grow over time?
- What queries/access patterns are needed?

**Write to:** `.designs/{{issue}}/data.md`

**Exit criteria:** data.md written with data model analysis.
"""

[[steps]]
id = "analyze-ux"
title = "User Experience Analysis"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze the user experience implications of this feature.

**Read context first:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Mental model: how users think about this
- Workflow integration: where does this fit in daily use?
- Learning curve: progressive disclosure
- Error experience: what happens when things go wrong?
- Feedback: how does the user know it's working?

**Questions to answer:**
- What's the user's goal when using this?
- What's the minimum viable interaction?
- How do we handle power users vs beginners?

**Write to:** `.designs/{{issue}}/ux.md`

**Exit criteria:** ux.md written with UX analysis.
"""

[[steps]]
id = "analyze-scale"
title = "Scalability Analysis"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze the scalability implications of this feature.

**Read context first:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Scale dimensions: data size, request rate, user count
- Resource usage: memory, CPU, disk, network
- Bottlenecks: what limits growth?
- Complexity: algorithmic, space, time
- Caching opportunities

**Questions to answer:**
- What happens at 10x, 100x, 1000x current scale?
- What are the hard limits?
- Where should we optimize vs keep simple?

**Write to:** `.designs/{{issue}}/scale.md`

**Exit criteria:** scale.md written with scalability analysis.
"""

[[steps]]
id = "analyze-security"
title = "Security Analysis"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze the security implications of this feature.

**Read context first:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Trust boundaries: what trusts what?
- Attack surface: new inputs, outputs, permissions
- Threat model: who might attack this and how?
- Sensitive data: what's exposed or stored?
- Authentication/authorization implications

**Questions to answer:**
- What's the worst case if this is exploited?
- What new permissions or access does this need?
- How do we validate/sanitize inputs?

**Write to:** `.designs/{{issue}}/security.md`

**Exit criteria:** security.md written with security analysis.
"""

[[steps]]
id = "analyze-integration"
title = "Integration Analysis"
needs = ["explore-codebase"]
tier = "opus"
description = """
Analyze how this feature integrates with the existing system.

**Read context first:**
- `.designs/{{issue}}/requirements.md`
- `.designs/{{issue}}/codebase-context.md`

**Explore:**
- Existing components: what does this touch?
- Dependencies: what does this need from others?
- Dependents: what will depend on this?
- Migration path: how do we get from here to there?
- Backwards compatibility: what might break?
- Testing strategy: how do we verify integration?

**Questions to answer:**
- Where does this code live?
- How does it affect existing workflows?
- Can we feature-flag or gradually roll out?

**Write to:** `.designs/{{issue}}/integration.md`

**Exit criteria:** integration.md written with integration analysis.
"""

# =============================================================================
# SYNTHESIS (with Rule-of-5 expansion)
# =============================================================================

[[steps]]
id = "synthesize"
title = "Synthesize design document"
needs = ["analyze-api", "analyze-data", "analyze-ux", "analyze-scale", "analyze-security", "analyze-integration"]
tier = "opus"
description = """
Combine all dimension analyses into a unified design document.

**Read all dimension analyses from `.designs/{{issue}}/`:**
- api.md, data.md, ux.md, scale.md, security.md, integration.md

**Write unified design to `.designs/{{issue}}/design-doc.md`:**

```markdown
# Design: {{issue}}

## Executive Summary
(2-3 paragraph overview of proposed design)

## Problem Statement
(From requirements.md)

## Proposed Design

### Overview
(High-level approach)

### Key Components
(Main pieces and how they fit together)

### Interface
(CLI/API summary from api dimension)

### Data Model
(Schema summary from data dimension)

## Trade-offs and Decisions

### Decisions Made
(Key choices and rationale)

### Open Questions
(Decisions needing human input - HIGHLIGHT THESE)

### Trade-offs
(What we're trading off and why)

## Risks and Mitigations
(From security and scale dimensions)

## Implementation Plan
(From integration dimension)

### Phase 1: MVP
### Phase 2: Polish
### Phase 3: Future

## Appendix: Dimension Analyses
- [API Design](api.md)
- [Data Model](data.md)
- [User Experience](ux.md)
- [Scalability](scale.md)
- [Security](security.md)
- [Integration](integration.md)
```

**Identify conflicts** between dimensions and flag them clearly.
**Highlight open questions** that need human decision.

**Exit criteria:** design-doc.md synthesized from all dimensions.
"""

# =============================================================================
# COMPOSITION: Rule-of-5 on Synthesis
# =============================================================================

[compose]
[[compose.expand]]
target = "synthesize"
with = "rule-of-five"

# =============================================================================
# POST-STEP: Create PR
# =============================================================================

[[steps]]
id = "create-pr"
title = "Create PR to main"
needs = ["synthesize"]
tier = "opus"
description = """
Push the design to the polecat branch and create a PR to main.

**1. Stage the design files:**
```bash
git add .designs/{{issue}}/
```

**2. Commit the design:**
```bash
git commit -m "design: architecture for {{issue}}

Adds comprehensive design document with:
- Requirements analysis
- 6-dimension analysis (API, data, UX, scale, security, integration)
- Rule-of-5 refined design document
- Implementation plan

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

**3. Push the branch:**
```bash
git push -u origin $(git branch --show-current)
```

**4. Create PR to main:**
```bash
gh pr create \
  --base main \
  --head $(git branch --show-current) \
  --title "Design: $(bd show {{issue}} --json | jq -r '.title')" \
  --body "$(cat <<'EOF'
## Design Document for {{issue}}

This PR contains the architecture design for the referenced issue.

### Contents
- `requirements.md` - Problem statement and success criteria
- `codebase-context.md` - Relevant code and patterns
- Dimension analyses: api.md, data.md, ux.md, scale.md, security.md, integration.md
- `design-doc.md` - Unified design document (Rule-of-5 refined)

### Review Focus
1. **Open Questions** - decisions needing human input
2. **Trade-offs** - are these acceptable?
3. **Implementation Plan** - is this realistic?
EOF
)"
```

**5. If issue bead was provided, update it:**
```bash
# Add label indicating design exists
bd label add {{issue}} "has-design"

# Get the PR URL
PR_URL=$(gh pr view --json url -q '.url')
BRANCH=$(git branch --show-current)

# Update bead notes with design link
bd update {{issue}} --notes "Design PR: $PR_URL
Design branch: $BRANCH
Design docs: .designs/{{issue}}/"
```

**6. Report completion:**
Output the PR URL.

**Exit criteria:** PR created, bead updated (if applicable), URL displayed.
"""

# =============================================================================
# POST-STEP: Exit without merge queue
# =============================================================================

[[steps]]
id = "exit-deferred"
title = "Exit without merge queue"
needs = ["create-pr"]
description = """
Design PRs need human review before merge. Exit WITHOUT submitting to merge queue.

**Important:** Design documents should be reviewed by humans before merging.
We use `--status DEFERRED` to skip MR creation. The PR is already on GitHub.

**Run gt done with DEFERRED status:**
```bash
gt done --status DEFERRED --cleanup-status clean
```

This will:
1. Notify Witness of completion
2. Clean up sandbox (worktree removal)
3. NOT create an MR in the merge queue

The GitHub PR is already created and awaits human review.

**What happens next:**
- Human reviews the design PR on GitHub
- Human merges when satisfied (or requests changes)
- The issue stays open with `has-design` label until implementation

You are GONE after this step.

**Exit criteria:** Session exited, PR awaits human review on GitHub.
"""

# =============================================================================
# VARIABLES
# =============================================================================

[vars]
[vars.issue]
description = "Bead ID to design for (e.g., gt-xxxx). Optional if 'problem' is provided."
required = false

[vars.problem]
description = "Problem statement string. Optional if 'issue' is provided."
required = false
